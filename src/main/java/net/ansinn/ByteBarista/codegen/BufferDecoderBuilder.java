package net.ansinn.ByteBarista.codegen;

import net.ansinn.ByteBarista.ClassUtils;
import net.ansinn.ByteBarista.NumericHelpers;
import net.ansinn.ByteBarista.annotations.UnsignedByte;
import net.ansinn.ByteBarista.annotations.UnsignedInteger;
import net.ansinn.ByteBarista.annotations.UnsignedShort;

import java.lang.classfile.CodeBuilder;
import java.lang.constant.ClassDesc;
import java.lang.constant.ConstantDescs;
import java.lang.constant.MethodTypeDesc;
import java.lang.reflect.RecordComponent;
import java.nio.ByteBuffer;

/**
 * Utility class responsible for generating bytecode instructions that deserialize {@link Record} types from a {@link ByteBuffer}.
 * <p>
 * This class provides methods for emitting low-level bytecode that reconstructs Java records by reading their fields in order
 * from a {@link ByteBuffer}. It supports primitive types and honors specific annotations such as {@link UnsignedByte},
 * {@link UnsignedShort}, and {@link UnsignedInteger} to handle unsigned data representations.
 * </p>
 *
 * <p>
 * The generated bytecode is intended for use in dynamically defined classes via the {@code java.lang.classfile} API.
 * These routines enable fast, direct memory parsing with strong type guarantees and zero runtime reflection cost.
 * </p>
 *
 * <p>
 * This class is not meant to be instantiated and should only be used internally during code generation.
 * </p>
 *
 * @see CodeBuilder
 * @see ByteBuffer
 * @see RecordCodecBuilder
 *
 * @author Gunter Ansinn
 */
public final class BufferDecoderBuilder {

    private BufferDecoderBuilder() {}

    /**
     * Emits bytecode that reads the fields of a record from a {@link ByteBuffer} and constructs a new instance of the record.
     * <p>
     * This method assumes that the {@link ByteBuffer} is positioned correctly and that enough data is available to fully
     * populate all fields of the given record. The generated method will follow the order of the record components
     * and invoke the corresponding {@link ByteBuffer} or helper methods for each primitive type.
     * </p>
     *
     * @param builder the {@link CodeBuilder} used to emit bytecode instructions
     * @param clazz   the record class whose constructor is being filled
     */
    static void emitReadFunction(CodeBuilder builder, Class<? extends Record> clazz) {

        // Build signature for record parameters to be used with constructor invocation
        var components = clazz.getRecordComponents();
        var methodDesc = buildSignature(components);

        var index = 1;

        // Iterate over every single record parameter emitting read functions for the bytebuffer
        // located in address 0 (since this method is static and not local)
        for (var component : components) {
            builder.aload(0);
            writeParserMethod(builder, component);
            builder.istore(index++);
        }

        // Create allocation instruction
        builder.new_(ClassDesc.of(clazz.getName())).dup();

        // Load in every variable for insertion into the constructor
        for (int i = 1; i < index; i++) {
            builder.iload(i);
        }

        // Emit instruction to return new value of class
        builder
                .invokespecial(
                        ClassDesc.of(clazz.getName()),
                        ConstantDescs.INIT_NAME,
                        MethodTypeDesc.ofDescriptor(methodDesc)
                ).areturn();
    }

    /**
     * Emits bytecode instructions to read a value of the given record component's type from a {@link ByteBuffer}.
     * <p>
     * This method inspects the component's type and any applicable unsigned annotations, then selects the appropriate
     * method to invoke on the {@link ByteBuffer} or {@link NumericHelpers}. The emitted bytecode
     * assumes the {@link ByteBuffer} instance is already on the stack.
     * </p>
     *
     * <p>
     * Supported primitive types include {@code byte}, {@code short}, {@code int}, {@code long}, {@code float},
     * {@code double}, and {@code char}. Any unsupported types or invalid annotation combinations (e.g., applying
     * {@link UnsignedInteger} to an {@code int}) will result in an
     * {@link IllegalStateException}.
     * </p>
     *
     * @param codeBuilder the {@link CodeBuilder} used to emit bytecode instructions
     * @param component   the record component whose value will be read from the {@link ByteBuffer}
     * @throws IllegalStateException if an unsupported type or annotation combination is encountered
     */
    private static void writeParserMethod(CodeBuilder codeBuilder, RecordComponent component) {
        var componentType = component.getType();

        switch (componentType.getTypeName()) {
            case "long" -> {
                if (component.isAnnotationPresent(UnsignedByte.class))
                    codeBuilder.invokevirtual(CodegenConstants.HELPER_DESC, "getUnsignedByteAsLong", CodegenConstants.BUFFER_LONG_LOAD);
                else if (component.isAnnotationPresent(UnsignedShort.class))
                    codeBuilder.invokevirtual(CodegenConstants.HELPER_DESC, "getUnsignedShortAsLong", CodegenConstants.BUFFER_LONG_LOAD);
                else if (component.isAnnotationPresent(UnsignedInteger.class))
                    codeBuilder.invokevirtual(CodegenConstants.HELPER_DESC, "getUnsignedInt", CodegenConstants.BUFFER_LONG_LOAD);
                else
                    codeBuilder.invokevirtual(CodegenConstants.BUFFER_DESC, "getLong", MethodTypeDesc.ofDescriptor("()J"));
            }
            case "int" -> {
                if (component.isAnnotationPresent(UnsignedByte.class))
                    codeBuilder.invokevirtual(CodegenConstants.HELPER_DESC, "getUnsignedByteAsInt", CodegenConstants.BUFFER_INT_LOAD);
                else if (component.isAnnotationPresent(UnsignedShort.class))
                    codeBuilder.invokevirtual(CodegenConstants.HELPER_DESC, "getUnsignedShortAsInt", CodegenConstants.BUFFER_INT_LOAD);
                else if (component.isAnnotationPresent(UnsignedInteger.class))
                    throw new IllegalStateException("You can't load an unsigned integer as an integer.");
                else
                    codeBuilder
                            .invokevirtual(CodegenConstants.BUFFER_DESC, "getInt", CodegenConstants.INT_DESC);
            }
            case "short" -> {
                codeBuilder
                        .invokevirtual(CodegenConstants.BUFFER_DESC, "getShort", CodegenConstants.SHORT_DESC);
            }
            case "byte" -> {
                codeBuilder
                        .invokevirtual(CodegenConstants.BUFFER_DESC, "get", CodegenConstants.BYTE_DESC);
            }

            case "double" -> {
                codeBuilder
                        .invokevirtual(CodegenConstants.BUFFER_DESC, "getDouble", MethodTypeDesc.ofDescriptor("()D"));
            }
            case "float" -> {
                codeBuilder
                        .invokevirtual(CodegenConstants.BUFFER_DESC, "getFloat", MethodTypeDesc.ofDescriptor("()F"));
            }

            case "char" -> {
                codeBuilder
                        .invokevirtual(CodegenConstants.BUFFER_DESC, "getChar", MethodTypeDesc.ofDescriptor("()C"));
            }

            default -> throw new IllegalStateException("Unexpected type: " + componentType.getTypeName());
        }
    }

    /**
     * Builds a method signature out of the parameter types within a record.
     *
     * @param components
     * @return a string representing the signature of the method.
     */
    private static String buildSignature(RecordComponent[] components) {
        var builder = new StringBuilder("(");
        for (RecordComponent component : components) {
            builder.append(ClassUtils.getDescriptor(component));
        }
        return builder.append(")V").toString();
    }
}